std::vector<CloudPoint> pcloud; //our global 3D point cloud

//check for matches between i'th frame and 0'th frame (and thus the current cloud)

std::vector<cv::Point3f> ppcloud;

std::vector<cv::Point2f> imgPoints;

vector<int> pcloud_status(pcloud.size(),0);

//scan the views we already used (good_views)
for (set<int>::iterator done_view = good_views.begin(); done_view != good_views.end(); ++done_view) {

	int old_view = *done_view; //a view we already used for reconstrcution
	//check for matches_from_old_to_working between
	<working_view>'th frame and <old_view>'th frame (and thus the current cloud)
	std::vector<cv::DMatch> matches_from_old_to_working = matches_matrix[std::make_pair(old_view,working_view)];

	//scan the 2D-2D matched-points

	for (unsigned int match_from_old_view=0; match_from_old_view<matches_from_old_to_working.size(); match_from_old_view++) {
	// the index of the matching 2D point in <old_view>
		int idx_in_old_view = matches_from_old_to_working[match_from_old_view].queryIdx;
		
		//scan the existing cloud to see if this point from <old_view>
		
		exists for (unsigned int pcldp=0; pcldp<pcloud.size(); pcldp++) {
			
			// see if this 2D point from <old_view> contributed to this 3D point in the cloud
			if (idx_in_old_view == pcloud[pcldp].index_of_2d_origin[old_view] && pcloud_status[pcldp] == 0) //prevent duplicates{
				//3d point in cloud
				ppcloud.push_back(pcloud[pcldp].pt);
				//2d point in image <working_view>
				Point2d pt_ = imgpts[working_view][matches_from_old_to_working[match_from_old_view].trainIdx].pt;
				imgPoints.push_back(pt_);
				pcloud_status[pcldp] = 1;
				break;
			}
		}
	}
}
cout<<"found "<<ppcloud.size() <<" 3d-2d point correspondences"<<endl;